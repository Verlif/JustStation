# 限流器

限流器使用了AOP切面的方式，通过注解与构造限流器完成接口限流功能。

## 使用

在需要限流的接口上加上`@Limit`注解就OK。例如：

```java
@RestController
@RequestMapping("/public")
public class PublicController {

    @LogIt(message = "test")
    @Limit(key = "test1", type = DefaultLimitHandler.class)
    @GetMapping("/test1")
    public BaseResult<String> test1() {
        return new OkResult<>();
    }

    @LogIt(message = "test2")
    @Limit(key = "test2", type = RandomLimitHandler.class)
    @GetMapping("/test2")
    public BaseResult<String> test2() {
        return new OkResult<>(test());
    }

    public String test() {
        return "test";
    }
}
```

注解上的参数Key表示了接口Key，某些接口共用相同的计数器的话，就用相同的key。参数type表示了要使用的限流器。

## 实现`LimitHandler`

`LimitHandler`只有一个方法需要实现`boolean arrived(String key)`，参数Key就是注解上的key值，返回值表示了接口是否可访问。

```java
@Component
@EnableScheduling
public class DefaultLimitHandler implements LimitHandler {

    /**
     * 单位时间内的可访问次数
     */
    private static final Integer COUNT_PER = 10;

    private final Map<String, Integer> countMap;

    public DefaultLimitHandler() {
        countMap = new ConcurrentHashMap<>();
    }

    @Override
    public boolean arrived(String key) {
        int count = getCount(key);
        if (count > 0) {
            consume(key);
            return true;
        }
        return false;
    }

    private int getCount(String key) {
        Integer count = countMap.get(key);
        return count == null ? COUNT_PER : count;
    }

    private void consume(String key) {
        countMap.put(key, getCount(key) - 1);
    }

    @Scheduled(cron = "0 0/1 * * * ?")
    private synchronized void reset() {
        countMap.replaceAll((k, v) -> COUNT_PER);
    }
}
```
